<!doctype html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lobster Widget Prototype</title>
  <style>
    :root {
      --panel-bg: transparent;
      --panel-border: none;
      --text: #f8fafc;
      --muted: #94a3b8;
      --sprite-size: 128px;
      --agent-width: 140px;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      margin: 0;
      background: transparent;
      color: var(--text);
      font-family: "Segoe UI", "Noto Sans JP", sans-serif;
    }

    body {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 12px;
      overflow: hidden;
    }

    body.drag-over .widget {
      outline: 2px dashed rgba(96, 165, 250, 0.9);
      outline-offset: 3px;
    }

    .widget {
      position: relative;
      width: min(1240px, 98vw);
      min-height: 260px;
      padding: 16px 18px 40px;
      background: transparent;
      overflow: hidden;
      transition: opacity 0.35s ease, transform 0.35s ease, box-shadow 0.2s ease;
    }

    .widget.dragging {
      cursor: grabbing;
      user-select: none;
    }

    .widget.always-on-top {
      box-shadow: 0 0 0 1px rgba(250, 204, 21, 0.75), 0 0 20px rgba(250, 204, 21, 0.25);
    }

    .widget.widget-hidden {
      opacity: 0;
      transform: scale(0.96) translateY(12px);
      pointer-events: none;
    }

    .sleep-overlay {
      position: absolute;
      inset: 0;
      z-index: 1;
      pointer-events: none;
      background: rgba(0, 0, 0, 0.72);
      opacity: 0;
      transition: opacity 10s linear;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .sleep-mode .sleep-overlay {
      opacity: 1;
    }

    .zzz {
      font-size: 32px;
      font-weight: 900;
      letter-spacing: 8px;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.85);
      text-shadow: 0 0 8px rgba(255, 255, 255, 0.2);
      opacity: 0;
      transform: translateY(18px) scale(0.9);
    }

    .sleep-mode .zzz {
      animation: zzzFloat 2.7s ease-in-out infinite;
    }

    .fallback,
    .count,
    .lobster-row,
    .ticker,
    .simple-message,
    .message-stage,
    .debug-panel {
      position: relative;
      z-index: 2;
    }

    .lobster-row {
      display: flex;
      align-items: flex-start;
      gap: 18px;
      padding-right: 88px;
      min-height: 190px;
      flex-wrap: wrap;
    }

    .agent {
      position: relative;
      width: var(--agent-width);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      flex-shrink: 0;
      background: transparent;
      opacity: 1;
      transform: translateY(0) scale(1);
      transition: opacity 0.42s ease, transform 0.42s ease;
    }

    .agent.entering {
      animation: lobsterEnter 0.62s cubic-bezier(0.2, 0.8, 0.2, 1);
    }

    .agent.leaving {
      opacity: 0;
      transform: translateY(14px) scale(0.88);
    }

    .agent-name {
      margin-bottom: 6px;
      font-size: 13px;
      font-weight: 700;
      letter-spacing: 0.3px;
      color: #cbd5e1;
      text-shadow: 0 0 4px rgba(0, 0, 0, 0.8), 0 0 2px rgba(0, 0, 0, 0.9);
      max-width: 100%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .sprite {
      width: var(--sprite-size);
      height: var(--sprite-size);
      image-rendering: pixelated;
      object-fit: contain;
      filter: drop-shadow(0 0 10px rgba(0, 0, 0, 0.4));
      cursor: help;
      transform-origin: 50% 78%;
    }

    .agent-tooltip {
      position: absolute;
      left: 50%;
      bottom: calc(100% - 18px);
      transform: translate(-50%, 8px);
      min-width: 200px;
      max-width: 260px;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.24);
      background: rgba(2, 6, 23, 0.94);
      color: #e2e8f0;
      font-size: 12px;
      line-height: 1.35;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.18s ease, transform 0.18s ease;
      z-index: 5;
    }

    .tooltip-title {
      font-weight: 800;
      margin-bottom: 3px;
    }

    .tooltip-line {
      color: #cbd5e1;
      font-variant-numeric: tabular-nums;
    }

    .agent:hover .agent-tooltip,
    .agent:focus-within .agent-tooltip {
      opacity: 1;
      transform: translate(-50%, 0);
    }

    .sleep-mode .agent .sprite {
      animation: sleepSway 2.8s ease-in-out infinite;
    }

    .timer {
      margin-top: 5px;
      font-size: 12px;
      font-weight: 700;
      font-variant-numeric: tabular-nums;
      letter-spacing: 0.35px;
      animation: rainbow 3s linear infinite;
      text-shadow: 0 0 4px rgba(0, 0, 0, 0.8), 0 0 2px rgba(0, 0, 0, 0.9);
      min-height: 16px;
    }

    .count {
      position: absolute;
      top: 8px;
      right: 16px;
      font-size: 28px;
      font-weight: 900;
      letter-spacing: 0.8px;
      text-shadow: 0 0 12px rgba(0, 0, 0, 0.6);
      user-select: none;
      color: #94a3b8;
    }

    .count-value {
      display: inline-block;
    }

    .count-value.pop {
      animation: countPop 0.34s ease;
    }

    .count.danger {
      color: #ff4d4d !important;
      animation: countBlink 0.8s steps(1) infinite;
    }

    .fallback {
      position: absolute;
      top: 10px;
      left: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
      z-index: 3;
    }

    .fallback button {
      border: 1px solid rgba(255, 255, 255, 0.25);
      background: rgba(15, 23, 42, 0.85);
      color: var(--text);
      border-radius: 6px;
      padding: 4px 8px;
      font-size: 12px;
      cursor: pointer;
    }

    #loadJsonBtn {
      display: none;
    }

    body.debug-mode #loadJsonBtn {
      display: inline-block;
    }

    .source-status {
      font-size: 11px;
      color: var(--muted);
      max-width: 420px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      display: none;
    }

    body.debug-mode .source-status {
      display: inline-block;
    }

    .debug-panel {
      position: absolute;
      top: 38px;
      right: 14px;
      min-width: 260px;
      max-width: min(48vw, 420px);
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(2, 6, 23, 0.84);
      color: #93c5fd;
      font-size: 11px;
      line-height: 1.35;
      white-space: pre-wrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 4;
    }

    .debug-panel.show {
      opacity: 1;
    }

    .message-stage {
      position: absolute;
      left: calc(var(--agent-width) + 42px);
      right: 14px;
      top: clamp(64px, 13vh, 108px);
      min-height: 42px;
      pointer-events: none;
    }

    .message-balloon {
      position: relative;
      display: none;
      max-width: min(640px, 82vw);
      padding: 8px 12px;
      border-radius: 12px;
      background: #ffffff;
      color: #0f172a;
      font-size: 13px;
      font-weight: 700;
      line-height: 1.4;
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.35);
      transform: translateY(4px);
      opacity: 0;
      transition: opacity 0.2s ease, transform 0.2s ease;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .message-balloon::before {
      content: "";
      position: absolute;
      left: -9px;
      top: 12px;
      width: 0;
      height: 0;
      border-top: 8px solid transparent;
      border-bottom: 8px solid transparent;
      border-right: 10px solid #ffffff;
    }

    .simple-message {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 4px;
      height: 20px;
      padding: 0 10px;
      display: none;
      align-items: center;
      background: rgba(0, 0, 0, 0.5);
      color: #e2e8f0;
      font-size: 13px;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      opacity: 1;
      transition: opacity 0.2s ease;
    }

    .simple-message.fade-out {
      opacity: 0;
    }

    .ticker {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 4px;
      height: 20px;
      overflow: hidden;
      background: rgba(0, 0, 0, 0.5);
    }

    .ticker-track {
      display: inline-block;
      padding-left: 100%;
      white-space: nowrap;
      line-height: 20px;
      font-size: 13px;
      font-weight: 600;
      color: #e2e8f0;
      animation: marquee 12s linear infinite;
      opacity: 1;
      transition: opacity 0.2s ease;
      will-change: transform;
    }

    .ticker-track.fade-out {
      opacity: 0;
    }

    .widget.style-ticker .ticker {
      display: block;
    }

    .widget.style-ticker .simple-message,
    .widget.style-ticker .message-stage {
      display: none;
    }

    .widget.style-balloon .ticker,
    .widget.style-balloon .simple-message {
      display: none;
    }

    .widget.style-balloon .message-balloon {
      display: block;
      opacity: 1;
      transform: translateY(0);
    }

    .widget.style-simple .ticker,
    .widget.style-simple .message-stage {
      display: none;
    }

    .widget.style-simple .simple-message {
      display: flex;
    }

    .context-menu {
      position: fixed;
      min-width: 216px;
      padding: 6px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(2, 6, 23, 0.95);
      box-shadow: 0 10px 28px rgba(0, 0, 0, 0.4);
      z-index: 20;
      opacity: 0;
      transform: translateY(6px);
      pointer-events: none;
      transition: opacity 0.14s ease, transform 0.14s ease;
    }

    .context-menu.show {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }

    .context-item {
      display: block;
      width: 100%;
      text-align: left;
      border: 0;
      background: transparent;
      color: #e2e8f0;
      border-radius: 7px;
      padding: 7px 10px;
      font-size: 13px;
      cursor: pointer;
    }

    .context-item:hover {
      background: rgba(148, 163, 184, 0.2);
    }

    .menu-group {
      margin: 4px 0;
      padding: 4px 6px 6px;
      border-radius: 8px;
      background: rgba(15, 23, 42, 0.6);
    }

    .menu-group-title {
      margin: 0 0 6px;
      font-size: 12px;
      color: #cbd5e1;
    }

    .size-options {
      display: flex;
      gap: 6px;
    }

    .size-option {
      flex: 1;
      border: 1px solid rgba(148, 163, 184, 0.35);
      border-radius: 6px;
      background: rgba(30, 41, 59, 0.8);
      color: #e2e8f0;
      font-size: 12px;
      padding: 5px 0;
      cursor: pointer;
    }

    .size-option.active {
      border-color: rgba(250, 204, 21, 0.95);
      background: rgba(234, 179, 8, 0.22);
      color: #fde68a;
      font-weight: 700;
    }

    .style-options {
      display: grid;
      gap: 6px;
    }

    .style-option {
      width: 100%;
      border: 1px solid rgba(148, 163, 184, 0.35);
      border-radius: 6px;
      background: rgba(30, 41, 59, 0.8);
      color: #e2e8f0;
      font-size: 12px;
      padding: 5px 8px;
      text-align: left;
      cursor: pointer;
    }

    .style-option.active {
      border-color: rgba(125, 211, 252, 0.95);
      background: rgba(14, 116, 144, 0.35);
      color: #e0f2fe;
      font-weight: 700;
    }

    .sleep-mode .count,
    .sleep-mode .ticker,
    .sleep-mode .simple-message,
    .sleep-mode .message-stage,
    .sleep-mode .timer {
      display: none;
    }

    .sleep-mode .lobster-row {
      min-height: 150px;
      align-items: center;
    }

    @media (max-width: 860px) {
      .widget {
        min-height: 190px;
        padding: 14px 12px 36px;
      }

      .lobster-row {
        gap: 10px;
        padding-right: 50px;
        min-height: 120px;
      }

      .agent-name {
        font-size: 11px;
      }

      .count {
        font-size: 22px;
        right: 10px;
      }

      .fallback {
        gap: 4px;
      }

      .fallback button {
        font-size: 11px;
        padding: 3px 6px;
      }

      .source-status {
        max-width: 220px;
      }

      .message-stage {
        left: max(6px, calc(var(--agent-width) + 10px));
        right: 8px;
        top: 58px;
      }
    }

    @keyframes rainbow {
      0% {
        color: #ff4d4d;
      }
      16% {
        color: #ffa500;
      }
      33% {
        color: #ffe84d;
      }
      50% {
        color: #4dff88;
      }
      66% {
        color: #5ac8ff;
      }
      83% {
        color: #b082ff;
      }
      100% {
        color: #ff4dca;
      }
    }

    @keyframes marquee {
      0% {
        transform: translateX(0);
      }
      100% {
        transform: translateX(-100%);
      }
    }

    @keyframes lobsterEnter {
      0% {
        opacity: 0;
        transform: translateY(22px) scale(0.72);
      }
      58% {
        opacity: 1;
        transform: translateY(-10px) scale(1.1);
      }
      100% {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    @keyframes sleepSway {
      0% {
        transform: rotate(0deg);
      }
      25% {
        transform: rotate(-3deg);
      }
      50% {
        transform: rotate(0deg);
      }
      75% {
        transform: rotate(3deg);
      }
      100% {
        transform: rotate(0deg);
      }
    }

    @keyframes zzzFloat {
      0% {
        opacity: 0;
        transform: translateY(18px) scale(0.9);
      }
      25% {
        opacity: 0.78;
      }
      100% {
        opacity: 0;
        transform: translateY(-26px) scale(1.18);
      }
    }

    @keyframes countPop {
      0% {
        transform: scale(1);
      }
      45% {
        transform: scale(1.3);
      }
      100% {
        transform: scale(1);
      }
    }

    @keyframes countBlink {
      0%,
      50% {
        opacity: 1;
        text-shadow: 0 0 14px rgba(255, 50, 50, 0.65);
      }
      51%,
      100% {
        opacity: 0.35;
        text-shadow: 0 0 4px rgba(255, 50, 50, 0.25);
      }
    }
  </style>
</head>
<body style="background: transparent">
  <div class="widget style-ticker" id="widget">
    <div class="sleep-overlay" aria-hidden="true">
      <div class="zzz">ZZZ</div>
    </div>

    <div class="fallback">
      <button id="loadJsonBtn" type="button">Load JSON (fallback)</button>
      <input id="jsonFileInput" type="file" accept=".json,application/json" hidden />
      <span id="sourceStatus" class="source-status">source: /agents</span>
    </div>

    <div class="debug-panel" id="debugPanel" aria-live="polite"></div>

    <div class="count" id="count"><span class="count-value" id="countValue">x0</span></div>
    <div class="lobster-row" id="lobsterRow"></div>
    <div class="message-stage" id="messageStage">
      <div class="message-balloon" id="balloonText">ü¶û [system] waiting...</div>
    </div>
    <div class="simple-message" id="simpleText">ü¶û [system] waiting...</div>
    <div class="ticker" id="ticker">
      <div class="ticker-track" id="tickerText">ü¶û [system] waiting...</div>
    </div>
  </div>

  <div class="context-menu" id="contextMenu" hidden>
    <button class="context-item" data-action="refresh">üîÑ „É™„Éï„É¨„ÉÉ„Ç∑„É•</button>
    <button class="context-item" data-action="sleep">üí§ „Çπ„É™„Éº„ÉóÂàáÊõø</button>

    <div class="menu-group">
      <p class="menu-group-title">üìè „Çµ„Ç§„Ç∫</p>
      <div class="size-options">
        <button class="size-option" data-action="size" data-size="small">üê£ Â∞è</button>
        <button class="size-option" data-action="size" data-size="medium">ü¶û ‰∏≠</button>
        <button class="size-option" data-action="size" data-size="large">ü¶ûü¶û Â§ß</button>
      </div>
    </div>

    <div class="menu-group">
      <p class="menu-group-title">üñºÔ∏è Ë°®Á§∫„Çπ„Çø„Ç§„É´</p>
      <div class="style-options">
        <button class="style-option" data-action="style" data-style="balloon">üí¨ Âêπ„ÅçÂá∫„Åó</button>
        <button class="style-option" data-action="style" data-style="ticker">üì∫ ÈõªÂÖâÊé≤Á§∫Êùø</button>
        <button class="style-option" data-action="style" data-style="simple">üìù „Ç∑„É≥„Éó„É´</button>
      </div>
    </div>

    <button class="context-item" id="alwaysOnTopItem" data-action="alwaysOnTop">üìå ÊúÄÂâçÈù¢: OFF</button>
    <button class="context-item" data-action="debug">‚ÑπÔ∏è „Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±</button>
    <button class="context-item" data-action="close">‚ùå Èñâ„Åò„Çã</button>
  </div>

  <script>
    const SPRITE_BASE = "../assets/sprites";
    const FRAME_COUNT = 4;
    const FRAME_MS = 250;
    const MAX_AGENTS = 8;
    const AGENTS_POLL_MS = 1000;
    const TODO_POLL_MS = 60_000;
    const SLEEP_AFTER_MS = 10 * 60_000;
    const SETTINGS_KEY = "lobster-widget-settings-v1";
    const MESSAGE_STYLES = ["ticker", "balloon", "simple"];

    const SIZE_PRESETS = {
      small: { sprite: 64, width: 88 },
      medium: { sprite: 128, width: 140 },
      large: { sprite: 192, width: 210 },
    };

    const CHAR_ICONS = {
      opus: "ü¶û",
      sonnet: "üü†",
      haiku: "üü¢",
      gemini: "üü°",
      kusomegane: "üü£",
      codex: "üòé",
      grok: "‚ö°",
      sleep: "üí§",
    };

    const state = {
      agents: [],
      sleepMode: false,
      manualSleep: false,
      frameIndex: 0,
      lastTickerText: "",
      tickerFadeTimer: null,
      messageStyle: "ticker",
      todoText: "",
      sourceStatus: "source: /agents",
      lastFetchError: "",
      lastActiveAt: Date.now(),
      lastRenderedCount: null,
      debugVisible: false,
      widgetHidden: false,
      widgetSize: "medium",
      alwaysOnTop: false,
      widgetPosition: null,
      contextMenuOpen: false,
      lastUpdateAt: null,
      errorCount: 0,
      drag: {
        active: false,
        pointerId: null,
        offsetX: 0,
        offsetY: 0,
        width: 0,
        height: 0,
      },
      agentNodes: new Map(),
      pollStatus: {
        agents: { state: "idle", lastAt: null, error: "" },
        todo: { state: "idle", lastAt: null, error: "" },
      },
    };

    const widget = document.getElementById("widget");
    const lobsterRow = document.getElementById("lobsterRow");
    const countEl = document.getElementById("count");
    const countValueEl = document.getElementById("countValue");
    const tickerTrackEl = document.getElementById("tickerText");
    const balloonTextEl = document.getElementById("balloonText");
    const simpleTextEl = document.getElementById("simpleText");
    const loadJsonBtn = document.getElementById("loadJsonBtn");
    const jsonFileInput = document.getElementById("jsonFileInput");
    const sourceStatusEl = document.getElementById("sourceStatus");
    const debugPanelEl = document.getElementById("debugPanel");
    const contextMenuEl = document.getElementById("contextMenu");
    const alwaysOnTopItemEl = document.getElementById("alwaysOnTopItem");
    const sizeOptionEls = Array.from(contextMenuEl.querySelectorAll(".size-option"));
    const styleOptionEls = Array.from(contextMenuEl.querySelectorAll(".style-option"));

    function clamp(value, min, max) {
      if (max < min) return min;
      return Math.min(max, Math.max(min, value));
    }

    function framePath(char, frameNumber) {
      return `${SPRITE_BASE}/${char}-frame${frameNumber}.png`;
    }

    function iconForChar(char) {
      return CHAR_ICONS[char] || "ü¶û";
    }

    function normalizeStarted(started) {
      if (started === null || started === undefined || started === "") return null;
      const n = Number(started);
      if (!Number.isFinite(n) || n <= 0) return null;
      return n > 1e12 ? n : n * 1000;
    }

    function normalizeAgents(payload) {
      const rawAgents = Array.isArray(payload)
        ? payload
        : Array.isArray(payload?.agents)
          ? payload.agents
          : [];

      return rawAgents
        .map((agent) => {
          if (!agent || typeof agent !== "object") return null;
          const char = String(agent.char || "opus").trim() || "opus";
          const task = typeof agent.task === "string" ? agent.task : "";
          const started = normalizeStarted(agent.started);
          return {
            char,
            task,
            started,
            isMain: Boolean(agent.isMain),
          };
        })
        .filter(Boolean)
        .slice(0, MAX_AGENTS);
    }

    function loadSettings() {
      try {
        const raw = localStorage.getItem(SETTINGS_KEY);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch {
        return null;
      }
    }

    function currentWidgetPosition() {
      const top = Number.parseFloat(widget.style.top);
      const left = Number.parseFloat(widget.style.left);
      if (!Number.isFinite(top) || !Number.isFinite(left)) {
        return state.widgetPosition;
      }
      return { top: Math.round(top), left: Math.round(left) };
    }

    function saveSettings() {
      try {
        const payload = {
          size: state.widgetSize,
          messageStyle: state.messageStyle,
          alwaysOnTop: state.alwaysOnTop,
          position: currentWidgetPosition(),
        };
        localStorage.setItem(SETTINGS_KEY, JSON.stringify(payload));
      } catch {
        // ignore storage errors
      }
    }

    function applyWidgetSize(size, { persist = true } = {}) {
      if (!SIZE_PRESETS[size]) return;
      state.widgetSize = size;
      const preset = SIZE_PRESETS[size];
      document.documentElement.style.setProperty("--sprite-size", `${preset.sprite}px`);
      document.documentElement.style.setProperty("--agent-width", `${preset.width}px`);
      updateContextMenuState();
      if (persist) {
        saveSettings();
      }
    }

    function applyAlwaysOnTop(enabled, { persist = true } = {}) {
      state.alwaysOnTop = Boolean(enabled);
      widget.classList.toggle("always-on-top", state.alwaysOnTop);
      updateContextMenuState();
      if (persist) {
        saveSettings();
      }
    }

    function applyMessageStyle(style, { persist = true } = {}) {
      const nextStyle = MESSAGE_STYLES.includes(style) ? style : "ticker";
      state.messageStyle = nextStyle;
      widget.classList.remove("style-ticker", "style-balloon", "style-simple");
      widget.classList.add(`style-${nextStyle}`);
      updateContextMenuState();
      if (persist) {
        saveSettings();
      }
    }

    function applyWidgetPosition(position, { persist = true } = {}) {
      if (!position) return;
      const top = Number(position.top);
      const left = Number(position.left);
      if (!Number.isFinite(top) || !Number.isFinite(left)) return;

      widget.style.position = "fixed";
      widget.style.top = `${Math.round(top)}px`;
      widget.style.left = `${Math.round(left)}px`;
      state.widgetPosition = { top: Math.round(top), left: Math.round(left) };

      if (persist) {
        saveSettings();
      }
    }

    function initializeSettings() {
      const saved = loadSettings();
      if (!saved || typeof saved !== "object") {
        applyWidgetSize("medium", { persist: false });
        applyMessageStyle("ticker", { persist: false });
        applyAlwaysOnTop(false, { persist: false });
        return;
      }

      applyWidgetSize(saved.size in SIZE_PRESETS ? saved.size : "medium", { persist: false });
      applyMessageStyle(MESSAGE_STYLES.includes(saved.messageStyle) ? saved.messageStyle : "ticker", { persist: false });
      applyAlwaysOnTop(Boolean(saved.alwaysOnTop), { persist: false });
      if (saved.position && typeof saved.position === "object") {
        applyWidgetPosition(saved.position, { persist: false });
      }
    }

    function visibleAgents() {
      if (state.sleepMode) {
        return [{ char: "sleep", task: "„Çπ„É™„Éº„Éó‰∏≠", started: null, isMain: true }];
      }
      return state.agents.slice(0, MAX_AGENTS);
    }

    function formatElapsed(startedAt) {
      if (!startedAt) return "--:--";
      const sec = Math.max(0, Math.floor((Date.now() - startedAt) / 1000));
      const mm = String(Math.floor(sec / 60)).padStart(2, "0");
      const ss = String(sec % 60).padStart(2, "0");
      return `${mm}:${ss}`;
    }

    function formatStarted(startedAt) {
      if (!startedAt) return "--:-- JST";
      const value = new Date(startedAt).toLocaleTimeString("ja-JP", {
        hour: "2-digit",
        minute: "2-digit",
        hour12: false,
        timeZone: "Asia/Tokyo",
      });
      return `${value} JST`;
    }

    function countColor(count) {
      if (count <= 0) return "#94a3b8";
      // Hand-tuned 7-stop palette: each count is visually distinct
      const palette = {
        1: "#00ff50",  // bright green
        2: "#64ff00",  // lime
        3: "#c8e600",  // yellow-green
        4: "#ffc800",  // yellow-orange
        5: "#ff7800",  // orange
        6: "#ff3200",  // red-orange
        7: "#ff0000",  // pure red
      };
      const c = Math.min(7, Math.max(1, count));
      return palette[c] || "#ff0000";
    }

    function currentMessageText() {
      if (state.sleepMode) return "üí§ [sleep] „Åä„ÇÑ„Åô„Åø‰∏≠...";

      const active = state.agents
        .filter((agent) => agent.task)
        .sort((a, b) => (b.started || 0) - (a.started || 0));

      if (active.length > 0) {
        const focus = active[0];
        return `${iconForChar(focus.char)} [${focus.char}] ${focus.task}`;
      }

      if (state.todoText) {
        return `ü¶û [todo] ${state.todoText}`;
      }

      if (state.lastFetchError) {
        return "ü¶û ‚ö† /agents „ÇíÂèñÂæó„Åß„Åç„Åæ„Åõ„ÇìÔºàJSON„Çí„Éâ„É©„ÉÉ„Ç∞&„Éâ„É≠„ÉÉ„ÉóÂèØËÉΩÔºâ";
      }

      return "ü¶û [system] waiting...";
    }

    function updateSourceStatus(text) {
      state.sourceStatus = text;
      sourceStatusEl.textContent = text;
      updateDebugPanel();
    }

    function refreshSleepMode() {
      if (state.manualSleep) {
        state.sleepMode = true;
        return;
      }

      if (state.agents.length > 0) {
        state.lastActiveAt = Date.now();
        state.sleepMode = false;
        return;
      }

      state.sleepMode = Date.now() - state.lastActiveAt >= SLEEP_AFTER_MS;
    }

    function agentKey(agent) {
      if (agent.char === "sleep") return "sleep";
      return `${agent.char}`;
    }

    function createAgentNode(agent) {
      const agentEl = document.createElement("div");
      agentEl.className = "agent entering";

      const nameEl = document.createElement("div");
      nameEl.className = "agent-name";

      const imgEl = document.createElement("img");
      imgEl.className = "sprite";
      imgEl.loading = "lazy";
      imgEl.addEventListener("error", () => {
        if (imgEl.dataset.fallback === "1") return;
        imgEl.dataset.fallback = "1";
        imgEl.src = framePath("opus", ((state.frameIndex % FRAME_COUNT) + 1));
      });

      const timerEl = document.createElement("div");
      timerEl.className = "timer";

      const tooltipEl = document.createElement("div");
      tooltipEl.className = "agent-tooltip";

      const tooltipTitleEl = document.createElement("div");
      tooltipTitleEl.className = "tooltip-title";
      const tooltipTaskEl = document.createElement("div");
      tooltipTaskEl.className = "tooltip-line";
      const tooltipTimeEl = document.createElement("div");
      tooltipTimeEl.className = "tooltip-line";
      const tooltipStartedEl = document.createElement("div");
      tooltipStartedEl.className = "tooltip-line";

      tooltipEl.appendChild(tooltipTitleEl);
      tooltipEl.appendChild(tooltipTaskEl);
      tooltipEl.appendChild(tooltipTimeEl);
      tooltipEl.appendChild(tooltipStartedEl);

      agentEl.appendChild(nameEl);
      agentEl.appendChild(imgEl);
      agentEl.appendChild(timerEl);
      agentEl.appendChild(tooltipEl);

      agentEl.addEventListener("animationend", () => {
        agentEl.classList.remove("entering");
      }, { once: true });

      return {
        el: agentEl,
        nameEl,
        imgEl,
        timerEl,
        tooltipTitleEl,
        tooltipTaskEl,
        tooltipTimeEl,
        tooltipStartedEl,
        char: agent.char,
        removing: false,
      };
    }

    function updateAgentNode(node, agent, idx) {
      const frameNumber = ((state.frameIndex + idx) % FRAME_COUNT) + 1;

      if (node.char !== agent.char) {
        delete node.imgEl.dataset.fallback;
      }

      node.char = agent.char;
      node.nameEl.textContent = agent.char;
      node.imgEl.alt = agent.char;

      const spriteChar = node.imgEl.dataset.fallback === "1" ? "opus" : agent.char;
      const nextSrc = framePath(spriteChar, frameNumber);
      // Compare using getAttribute (relative) not .src (absolute) to avoid always-true mismatch
      if (node.imgEl.getAttribute("src") !== nextSrc) {
        node.imgEl.src = nextSrc;
      }

      node.timerEl.style.animationDelay = `${idx * 0.2}s`;
      // Guard DOM updates: only write when value changed
      const timerText = formatElapsed(agent.started);
      if (node.timerEl.textContent !== timerText) node.timerEl.textContent = timerText;

      const ttTitle = `${iconForChar(agent.char)} ${agent.char}`;
      if (node.tooltipTitleEl.textContent !== ttTitle) node.tooltipTitleEl.textContent = ttTitle;
      const ttTask = `Task: ${agent.task || "(task„Å™„Åó)"}`;
      if (node.tooltipTaskEl.textContent !== ttTask) node.tooltipTaskEl.textContent = ttTask;
      const ttTime = `Time: ${timerText}`;
      if (node.tooltipTimeEl.textContent !== ttTime) node.tooltipTimeEl.textContent = ttTime;
      const ttStarted = `Started: ${formatStarted(agent.started)}`;
      if (node.tooltipStartedEl.textContent !== ttStarted) node.tooltipStartedEl.textContent = ttStarted;
    }

    function removeAgentNode(key, node) {
      if (!node || node.removing) return;
      node.removing = true;
      node.el.classList.add("leaving");
      window.setTimeout(() => {
        if (node.el.isConnected) {
          node.el.remove();
        }
        state.agentNodes.delete(key);
      }, 430);
    }

    function syncAgentNodes(agents) {
      const desiredKeys = [];

      agents.forEach((agent, idx) => {
        const key = agentKey(agent);
        desiredKeys.push(key);

        let node = state.agentNodes.get(key);
        if (!node) {
          node = createAgentNode(agent);
          state.agentNodes.set(key, node);
        }

        if (node.removing) {
          node.removing = false;
          node.el.classList.remove("leaving");
        }

        updateAgentNode(node, agent, idx);
        lobsterRow.appendChild(node.el);
      });

      for (const [key, node] of state.agentNodes.entries()) {
        if (!desiredKeys.includes(key)) {
          removeAgentNode(key, node);
        }
      }
    }

    function triggerCountPop() {
      countValueEl.classList.remove("pop");
      void countValueEl.offsetWidth;
      countValueEl.classList.add("pop");
    }

    function updateCount(count) {
      countValueEl.textContent = `x${count}`;
      countEl.classList.toggle("danger", count >= 7);

      if (count < 7) {
        countEl.style.color = countColor(count);
      } else {
        countEl.style.color = "#ff4d4d";
      }

      if (state.lastRenderedCount !== count) {
        triggerCountPop();
        state.lastRenderedCount = count;
      }
    }

    function setMessageText(nextText) {
      if (nextText === state.lastTickerText) return;

      if (state.tickerFadeTimer) {
        clearTimeout(state.tickerFadeTimer);
      }

      tickerTrackEl.classList.add("fade-out");
      simpleTextEl.classList.add("fade-out");
      balloonTextEl.textContent = nextText;

      state.tickerFadeTimer = setTimeout(() => {
        tickerTrackEl.textContent = nextText;
        tickerTrackEl.style.animation = "none";
        void tickerTrackEl.offsetWidth;
        tickerTrackEl.style.animation = "marquee 12s linear infinite";
        tickerTrackEl.classList.remove("fade-out");

        simpleTextEl.textContent = nextText;
        simpleTextEl.classList.remove("fade-out");
        balloonTextEl.textContent = nextText;

        state.lastTickerText = nextText;
      }, 160);
    }

    function formatPollTime(ts) {
      if (!ts) return "--:--:--";
      return new Date(ts).toLocaleTimeString("ja-JP", { hour12: false, timeZone: "Asia/Tokyo" });
    }

    function updateDebugPanel() {
      const source = state.sourceStatus || "source: unknown";
      const activeCount = state.sleepMode ? 0 : state.agents.length;
      const sizePx = SIZE_PRESETS[state.widgetSize]?.sprite || 128;

      debugPanelEl.textContent = [
        source,
        `agents: ${activeCount} active`,
        `polling: ${AGENTS_POLL_MS / 1000}s (agents) / ${TODO_POLL_MS / 1000}s (todo)`,
        `last update: ${formatPollTime(state.lastUpdateAt)}`,
        `errors: ${state.errorCount}`,
        `size: ${state.widgetSize} (${sizePx}px)`,
        `style: ${state.messageStyle}`,
        `always on top: ${state.alwaysOnTop ? "ON" : "OFF"}`,
      ].join("\n");

      debugPanelEl.classList.toggle("show", state.debugVisible);
    }

    function markPoll(kind, status, error = "") {
      state.pollStatus[kind] = {
        state: status,
        lastAt: Date.now(),
        error,
      };
      state.lastUpdateAt = Date.now();
      if (status === "error") {
        state.errorCount += 1;
      }
      updateDebugPanel();
    }

    function render() {
      refreshSleepMode();
      const agents = visibleAgents();

      widget.classList.toggle("sleep-mode", state.sleepMode);
      widget.classList.toggle("widget-hidden", state.widgetHidden);

      syncAgentNodes(agents);

      const count = state.sleepMode ? 0 : agents.length;
      updateCount(count);

      setMessageText(currentMessageText());
      updateDebugPanel();
    }

    function tickFrame() {
      state.frameIndex = (state.frameIndex + 1) % FRAME_COUNT;
      render();
    }

    let _agentsPollInFlight = false;
    async function pollAgents() {
      if (_agentsPollInFlight) return; // in-flight guard: skip if previous fetch still running
      _agentsPollInFlight = true;
      markPoll("agents", "polling");
      try {
        const response = await fetch("/agents", { cache: "no-store" });
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        const payload = await response.json();
        state.agents = normalizeAgents(payload);
        state.lastFetchError = "";
        if (state.agents.length > 0) {
          state.lastActiveAt = Date.now();
        }
        updateSourceStatus("source: live /agents");
        markPoll("agents", "ok");
        render();
      } catch (error) {
        state.lastFetchError = error?.message || "fetch failed";
        updateSourceStatus(`source: fallback (${state.lastFetchError})`);
        markPoll("agents", "error", state.lastFetchError);
        render();
      } finally {
        _agentsPollInFlight = false;
      }
    }

    async function pollTodo() {
      markPoll("todo", "polling");
      try {
        const response = await fetch("/todo", { cache: "no-store" });
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        const payload = await response.json();
        if (typeof payload?.todo === "string") {
          state.todoText = payload.todo.trim();
        } else if (typeof payload === "string") {
          state.todoText = payload.trim();
        }
        markPoll("todo", "ok");
        render();
      } catch (error) {
        markPoll("todo", "error", error?.message || "fetch failed");
      }
    }

    async function loadAgentsFromFile(file) {
      if (!file) return;
      try {
        const text = await file.text();
        const payload = JSON.parse(text);
        const parsed = normalizeAgents(payload);
        state.agents = parsed;
        if (parsed.length > 0) {
          state.lastActiveAt = Date.now();
        }
        state.lastFetchError = "";
        updateSourceStatus(`source: local file (${file.name})`);
        state.lastUpdateAt = Date.now();
        render();
      } catch (error) {
        state.errorCount += 1;
        updateSourceStatus(`source: local file error (${error?.message || "invalid json"})`);
      }
    }

    function toggleManualSleep() {
      state.manualSleep = !state.manualSleep;
      if (!state.manualSleep && state.agents.length > 0) {
        state.lastActiveAt = Date.now();
      }
      render();
    }

    function toggleDebug() {
      state.debugVisible = !state.debugVisible;
      document.body.classList.toggle("debug-mode", state.debugVisible);
      updateDebugPanel();
    }

    function toggleWidgetHidden() {
      state.widgetHidden = !state.widgetHidden;
      render();
    }

    function toggleAlwaysOnTop() {
      applyAlwaysOnTop(!state.alwaysOnTop);
      render();
    }

    function updateContextMenuState() {
      alwaysOnTopItemEl.textContent = `üìå ÊúÄÂâçÈù¢: ${state.alwaysOnTop ? "ON" : "OFF"}`;
      sizeOptionEls.forEach((el) => {
        el.classList.toggle("active", el.dataset.size === state.widgetSize);
      });
      styleOptionEls.forEach((el) => {
        el.classList.toggle("active", el.dataset.style === state.messageStyle);
      });
    }

    function openContextMenu(clientX, clientY) {
      updateContextMenuState();
      contextMenuEl.hidden = false;
      contextMenuEl.classList.add("show");
      state.contextMenuOpen = true;

      const rect = contextMenuEl.getBoundingClientRect();
      const pad = 8;
      const left = clamp(clientX, pad, window.innerWidth - rect.width - pad);
      const top = clamp(clientY, pad, window.innerHeight - rect.height - pad);
      contextMenuEl.style.left = `${left}px`;
      contextMenuEl.style.top = `${top}px`;
    }

    function closeContextMenu() {
      if (!state.contextMenuOpen) return;
      state.contextMenuOpen = false;
      contextMenuEl.classList.remove("show");
      contextMenuEl.hidden = true;
    }

    function shouldStartDrag(target) {
      return !target.closest("button, input, .context-menu, .sprite, .agent-tooltip");
    }

    function handleDragStart(event) {
      if (event.button !== 0) return;
      if (!shouldStartDrag(event.target)) return;
      if (state.widgetHidden) return;

      const rect = widget.getBoundingClientRect();
      if (getComputedStyle(widget).position !== "fixed") {
        widget.style.position = "fixed";
        widget.style.top = `${rect.top}px`;
        widget.style.left = `${rect.left}px`;
      }

      state.drag.active = true;
      state.drag.pointerId = event.pointerId;
      state.drag.offsetX = event.clientX - rect.left;
      state.drag.offsetY = event.clientY - rect.top;
      state.drag.width = rect.width;
      state.drag.height = rect.height;

      widget.classList.add("dragging");
      widget.setPointerCapture(event.pointerId);
      event.preventDefault();
    }

    function handleDragMove(event) {
      if (!state.drag.active || event.pointerId !== state.drag.pointerId) return;

      const maxLeft = window.innerWidth - state.drag.width;
      const maxTop = window.innerHeight - state.drag.height;
      const left = clamp(event.clientX - state.drag.offsetX, 0, maxLeft);
      const top = clamp(event.clientY - state.drag.offsetY, 0, maxTop);

      widget.style.left = `${Math.round(left)}px`;
      widget.style.top = `${Math.round(top)}px`;
    }

    function finishDrag(event) {
      if (!state.drag.active || event.pointerId !== state.drag.pointerId) return;

      state.drag.active = false;
      widget.classList.remove("dragging");
      try {
        widget.releasePointerCapture(event.pointerId);
      } catch {
        // ignore
      }

      state.widgetPosition = currentWidgetPosition();
      saveSettings();
    }

    loadJsonBtn.addEventListener("click", () => jsonFileInput.click());
    jsonFileInput.addEventListener("change", (event) => {
      const file = event.target.files?.[0];
      loadAgentsFromFile(file);
      event.target.value = "";
    });

    document.addEventListener("dragover", (event) => {
      event.preventDefault();
      document.body.classList.add("drag-over");
    });

    document.addEventListener("dragleave", () => {
      document.body.classList.remove("drag-over");
    });

    document.addEventListener("drop", (event) => {
      event.preventDefault();
      document.body.classList.remove("drag-over");
      const file = event.dataTransfer?.files?.[0];
      loadAgentsFromFile(file);
    });

    widget.addEventListener("contextmenu", (event) => {
      event.preventDefault();
      openContextMenu(event.clientX, event.clientY);
    });

    contextMenuEl.addEventListener("click", (event) => {
      const actionEl = event.target.closest("[data-action]");
      if (!actionEl) return;

      const action = actionEl.dataset.action;

      if (action === "refresh") {
        pollAgents();
        pollTodo();
        render();
        closeContextMenu();
        return;
      }

      if (action === "sleep") {
        toggleManualSleep();
        closeContextMenu();
        return;
      }

      if (action === "size") {
        applyWidgetSize(actionEl.dataset.size);
        render();
        closeContextMenu();
        return;
      }

      if (action === "style") {
        applyMessageStyle(actionEl.dataset.style);
        render();
        closeContextMenu();
        return;
      }

      if (action === "alwaysOnTop") {
        toggleAlwaysOnTop();
        closeContextMenu();
        return;
      }

      if (action === "debug") {
        toggleDebug();
        closeContextMenu();
        return;
      }

      if (action === "close") {
        toggleWidgetHidden();
        closeContextMenu();
      }
    });

    document.addEventListener("pointerdown", (event) => {
      if (!state.contextMenuOpen) return;
      if (contextMenuEl.contains(event.target)) return;
      closeContextMenu();
    });

    window.addEventListener("resize", () => {
      if (state.contextMenuOpen) {
        closeContextMenu();
      }
    });

    widget.addEventListener("pointerdown", handleDragStart);
    widget.addEventListener("pointermove", handleDragMove);
    widget.addEventListener("pointerup", finishDrag);
    widget.addEventListener("pointercancel", finishDrag);

    document.addEventListener("keydown", (event) => {
      const tagName = event.target?.tagName;
      if (tagName === "INPUT" || tagName === "TEXTAREA") return;

      if (event.key === "s" || event.key === "S") {
        event.preventDefault();
        toggleManualSleep();
        return;
      }

      if (event.key === "d" || event.key === "D") {
        event.preventDefault();
        toggleDebug();
        return;
      }

      if (event.key === "Escape") {
        event.preventDefault();
        if (state.contextMenuOpen) {
          closeContextMenu();
          return;
        }
        toggleWidgetHidden();
      }
    });

    window.addEventListener("beforeunload", () => {
      state.widgetPosition = currentWidgetPosition();
      saveSettings();
    });

    // Adaptive polling: slower when sleeping (5s), normal when active (1s)
    let _agentsPollTimer = null;
    let _currentPollMs = AGENTS_POLL_MS;
    function scheduleAgentsPoll() {
      const targetMs = state.sleepMode ? 5000 : AGENTS_POLL_MS;
      if (_agentsPollTimer && _currentPollMs === targetMs) return;
      if (_agentsPollTimer) clearInterval(_agentsPollTimer);
      _currentPollMs = targetMs;
      _agentsPollTimer = setInterval(pollAgents, targetMs);
    }

    // Hook refreshSleepMode to also adjust poll rate
    const _origRefreshSleep = refreshSleepMode;
    refreshSleepMode = function() { _origRefreshSleep(); scheduleAgentsPoll(); };

    initializeSettings();
    document.body.classList.toggle("debug-mode", state.debugVisible);
    updateContextMenuState();
    render();
    pollAgents();
    pollTodo();
    setInterval(tickFrame, FRAME_MS);
    scheduleAgentsPoll();
    setInterval(pollTodo, TODO_POLL_MS);
  </script>
</body>
</html>
