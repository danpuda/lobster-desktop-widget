<!doctype html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lobster Widget Prototype</title>
  <style>
    :root {
      --panel-bg: rgba(0, 0, 0, 0.7);
      --panel-border: rgba(255, 255, 255, 0.18);
      --text: #f8fafc;
      --muted: #94a3b8;
      --sprite-size: 128px;
      --agent-width: 140px;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      margin: 0;
      background: transparent;
      color: var(--text);
      font-family: "Segoe UI", "Noto Sans JP", sans-serif;
    }

    body {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 12px;
    }

    body.drag-over .widget {
      outline: 2px dashed rgba(96, 165, 250, 0.9);
      outline-offset: 3px;
    }

    .widget {
      position: relative;
      width: min(1240px, 98vw);
      min-height: 260px;
      padding: 16px 18px 40px;
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 14px;
      overflow: hidden;
      backdrop-filter: blur(2px);
      transition: opacity 0.35s ease, transform 0.35s ease;
    }

    .widget.widget-hidden {
      opacity: 0;
      transform: scale(0.96) translateY(12px);
      pointer-events: none;
    }

    .sleep-overlay {
      position: absolute;
      inset: 0;
      z-index: 1;
      pointer-events: none;
      background: rgba(0, 0, 0, 0.72);
      opacity: 0;
      transition: opacity 10s linear;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .sleep-mode .sleep-overlay {
      opacity: 1;
    }

    .zzz {
      font-size: 32px;
      font-weight: 900;
      letter-spacing: 8px;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.85);
      text-shadow: 0 0 8px rgba(255, 255, 255, 0.2);
      opacity: 0;
      transform: translateY(18px) scale(0.9);
    }

    .sleep-mode .zzz {
      animation: zzzFloat 2.7s ease-in-out infinite;
    }

    .fallback,
    .count,
    .lobster-row,
    .ticker,
    .debug-panel {
      position: relative;
      z-index: 2;
    }

    .lobster-row {
      display: flex;
      align-items: flex-start;
      gap: 18px;
      padding-right: 88px;
      min-height: 190px;
      flex-wrap: wrap;
    }

    .agent {
      width: var(--agent-width);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      flex-shrink: 0;
      opacity: 1;
      transform: translateY(0) scale(1);
      transition: opacity 0.42s ease, transform 0.42s ease;
    }

    .agent.entering {
      animation: lobsterEnter 0.62s cubic-bezier(0.2, 0.8, 0.2, 1);
    }

    .agent.leaving {
      opacity: 0;
      transform: translateY(14px) scale(0.88);
    }

    .agent-name {
      margin-bottom: 6px;
      font-size: 13px;
      font-weight: 700;
      letter-spacing: 0.3px;
      color: #cbd5e1;
      text-shadow: 0 0 8px rgba(0, 0, 0, 0.8);
      max-width: 100%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .sprite {
      width: var(--sprite-size);
      height: var(--sprite-size);
      image-rendering: pixelated;
      object-fit: contain;
      filter: drop-shadow(0 0 10px rgba(0, 0, 0, 0.4));
      cursor: help;
      transform-origin: 50% 78%;
    }

    .sleep-mode .agent .sprite {
      animation: sleepSway 2.8s ease-in-out infinite;
    }

    .timer {
      margin-top: 5px;
      font-size: 12px;
      font-weight: 700;
      font-variant-numeric: tabular-nums;
      letter-spacing: 0.35px;
      animation: rainbow 3s linear infinite;
      text-shadow: 0 0 8px rgba(255, 255, 255, 0.2);
      min-height: 16px;
    }

    .count {
      position: absolute;
      top: 8px;
      right: 16px;
      font-size: 28px;
      font-weight: 900;
      letter-spacing: 0.8px;
      text-shadow: 0 0 12px rgba(0, 0, 0, 0.6);
      user-select: none;
      color: #94a3b8;
    }

    .count-value {
      display: inline-block;
    }

    .count-value.pop {
      animation: countPop 0.34s ease;
    }

    .count.danger {
      color: #ff4d4d !important;
      animation: countBlink 0.8s steps(1) infinite;
    }

    .fallback {
      position: absolute;
      top: 10px;
      left: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
      z-index: 3;
    }

    .fallback button {
      border: 1px solid rgba(255, 255, 255, 0.25);
      background: rgba(15, 23, 42, 0.85);
      color: var(--text);
      border-radius: 6px;
      padding: 4px 8px;
      font-size: 12px;
      cursor: pointer;
    }

    .source-status {
      font-size: 11px;
      color: var(--muted);
      max-width: 420px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .debug-panel {
      position: absolute;
      top: 38px;
      right: 14px;
      min-width: 260px;
      max-width: min(48vw, 420px);
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(2, 6, 23, 0.84);
      color: #93c5fd;
      font-size: 11px;
      line-height: 1.35;
      white-space: pre-wrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 3;
    }

    .debug-panel.show {
      opacity: 1;
    }

    .ticker {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 4px;
      height: 24px;
      overflow: hidden;
      border-top: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(0, 0, 0, 0.28);
    }

    .ticker-track {
      display: inline-block;
      padding-left: 100%;
      white-space: nowrap;
      line-height: 24px;
      font-size: 13px;
      font-weight: 600;
      color: #e2e8f0;
      animation: marquee 12s linear infinite;
      opacity: 1;
      transition: opacity 0.2s ease;
      will-change: transform;
    }

    .ticker-track.fade-out {
      opacity: 0;
    }

    .sleep-mode .count,
    .sleep-mode .ticker,
    .sleep-mode .timer {
      display: none;
    }

    .sleep-mode .lobster-row {
      min-height: 150px;
      align-items: center;
    }

    @media (max-width: 860px) {
      :root {
        --sprite-size: 64px;
        --agent-width: 88px;
      }

      .widget {
        min-height: 190px;
        padding: 14px 12px 36px;
      }

      .lobster-row {
        gap: 10px;
        padding-right: 50px;
        min-height: 120px;
      }

      .agent-name {
        font-size: 11px;
      }

      .count {
        font-size: 22px;
        right: 10px;
      }

      .fallback {
        gap: 4px;
      }

      .fallback button {
        font-size: 11px;
        padding: 3px 6px;
      }

      .source-status {
        max-width: 220px;
      }
    }

    @keyframes rainbow {
      0% {
        color: #ff4d4d;
      }
      16% {
        color: #ffa500;
      }
      33% {
        color: #ffe84d;
      }
      50% {
        color: #4dff88;
      }
      66% {
        color: #5ac8ff;
      }
      83% {
        color: #b082ff;
      }
      100% {
        color: #ff4dca;
      }
    }

    @keyframes marquee {
      0% {
        transform: translateX(0);
      }
      100% {
        transform: translateX(-100%);
      }
    }

    @keyframes lobsterEnter {
      0% {
        opacity: 0;
        transform: translateY(22px) scale(0.72);
      }
      58% {
        opacity: 1;
        transform: translateY(-10px) scale(1.1);
      }
      100% {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    @keyframes sleepSway {
      0% {
        transform: rotate(0deg);
      }
      25% {
        transform: rotate(-3deg);
      }
      50% {
        transform: rotate(0deg);
      }
      75% {
        transform: rotate(3deg);
      }
      100% {
        transform: rotate(0deg);
      }
    }

    @keyframes zzzFloat {
      0% {
        opacity: 0;
        transform: translateY(18px) scale(0.9);
      }
      25% {
        opacity: 0.78;
      }
      100% {
        opacity: 0;
        transform: translateY(-26px) scale(1.18);
      }
    }

    @keyframes countPop {
      0% {
        transform: scale(1);
      }
      45% {
        transform: scale(1.3);
      }
      100% {
        transform: scale(1);
      }
    }

    @keyframes countBlink {
      0%,
      50% {
        opacity: 1;
        text-shadow: 0 0 14px rgba(255, 50, 50, 0.65);
      }
      51%,
      100% {
        opacity: 0.35;
        text-shadow: 0 0 4px rgba(255, 50, 50, 0.25);
      }
    }
  </style>
</head>
<body style="background: transparent">
  <div class="widget" id="widget">
    <div class="sleep-overlay" aria-hidden="true">
      <div class="zzz">ZZZ</div>
    </div>

    <div class="fallback">
      <button id="loadJsonBtn" type="button">Load JSON (fallback)</button>
      <input id="jsonFileInput" type="file" accept=".json,application/json" hidden />
      <span id="sourceStatus" class="source-status">source: /agents</span>
    </div>

    <div class="debug-panel" id="debugPanel" aria-live="polite"></div>

    <div class="count" id="count"><span class="count-value" id="countValue">x0</span></div>
    <div class="lobster-row" id="lobsterRow"></div>
    <div class="ticker" id="ticker">
      <div class="ticker-track" id="tickerText">ðŸ¦ž [system] waiting...</div>
    </div>
  </div>

  <script>
    const SPRITE_BASE = "../assets/sprites";
    const FRAME_COUNT = 4;
    const FRAME_MS = 250;
    const MAX_AGENTS = 8;
    const AGENTS_POLL_MS = 1000;
    const TODO_POLL_MS = 60_000;
    const SLEEP_AFTER_MS = 10 * 60_000;

    const CHAR_ICONS = {
      opus: "ðŸ¦ž",
      sonnet: "ðŸ”µ",
      haiku: "ðŸŸ¢",
      gemini: "ðŸŸ¡",
      kusomegane: "ðŸŸ£",
      codex: "ðŸ˜Ž",
      grok: "âš¡",
      sleep: "ðŸ’¤",
    };

    const state = {
      agents: [],
      sleepMode: false,
      manualSleep: false,
      frameIndex: 0,
      lastTickerText: "",
      tickerFadeTimer: null,
      todoText: "",
      sourceStatus: "source: /agents",
      lastFetchError: "",
      lastActiveAt: Date.now(),
      lastRenderedCount: null,
      debugVisible: false,
      widgetHidden: false,
      agentNodes: new Map(),
      pollStatus: {
        agents: { state: "idle", lastAt: null, error: "" },
        todo: { state: "idle", lastAt: null, error: "" },
      },
    };

    const widget = document.getElementById("widget");
    const lobsterRow = document.getElementById("lobsterRow");
    const countEl = document.getElementById("count");
    const countValueEl = document.getElementById("countValue");
    const tickerEl = document.getElementById("tickerText");
    const loadJsonBtn = document.getElementById("loadJsonBtn");
    const jsonFileInput = document.getElementById("jsonFileInput");
    const sourceStatusEl = document.getElementById("sourceStatus");
    const debugPanelEl = document.getElementById("debugPanel");

    function framePath(char, frameNumber) {
      return `${SPRITE_BASE}/${char}-frame${frameNumber}.png`;
    }

    function iconForChar(char) {
      return CHAR_ICONS[char] || "ðŸ¦ž";
    }

    function normalizeStarted(started) {
      if (started === null || started === undefined || started === "") return null;
      const n = Number(started);
      if (!Number.isFinite(n) || n <= 0) return null;
      return n > 1e12 ? n : n * 1000;
    }

    function normalizeAgents(payload) {
      const rawAgents = Array.isArray(payload)
        ? payload
        : Array.isArray(payload?.agents)
          ? payload.agents
          : [];

      return rawAgents
        .map((agent) => {
          if (!agent || typeof agent !== "object") return null;
          const char = String(agent.char || "opus").trim() || "opus";
          const task = typeof agent.task === "string" ? agent.task : "";
          const started = normalizeStarted(agent.started);
          return {
            char,
            task,
            started,
            isMain: Boolean(agent.isMain),
          };
        })
        .filter(Boolean)
        .slice(0, MAX_AGENTS);
    }

    function visibleAgents() {
      if (state.sleepMode) {
        return [{ char: "sleep", task: "ã‚¹ãƒªãƒ¼ãƒ—ä¸­", started: null, isMain: true }];
      }
      return state.agents.slice(0, MAX_AGENTS);
    }

    function formatElapsed(startedAt) {
      if (!startedAt) return "---";
      const sec = Math.max(0, Math.floor((Date.now() - startedAt) / 1000));
      const mm = String(Math.floor(sec / 60)).padStart(2, "0");
      const ss = String(sec % 60).padStart(2, "0");
      return `${mm}:${ss}`;
    }

    function countColor(count) {
      if (count <= 0) return "#94a3b8";
      const clamped = Math.min(7, Math.max(1, count));
      const t = (clamped - 1) / 6;
      const hue = 120 * (1 - t); // 120: green -> 0: red
      return `hsl(${hue} 95% 55%)`;
    }

    function currentTickerText() {
      if (state.sleepMode) return "ðŸ’¤ [sleep] ãŠã‚„ã™ã¿ä¸­...";

      const active = state.agents
        .filter((agent) => agent.task)
        .sort((a, b) => (b.started || 0) - (a.started || 0));

      if (active.length > 0) {
        const focus = active[0];
        return `${iconForChar(focus.char)} [${focus.char}] ${focus.task}`;
      }

      if (state.todoText) {
        return `ðŸ¦ž [todo] ${state.todoText}`;
      }

      if (state.lastFetchError) {
        return "ðŸ¦ž âš  /agents ã‚’å–å¾—ã§ãã¾ã›ã‚“ï¼ˆJSONã‚’ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—å¯èƒ½ï¼‰";
      }

      return "ðŸ¦ž [system] waiting...";
    }

    function updateSourceStatus(text) {
      state.sourceStatus = text;
      sourceStatusEl.textContent = text;
    }

    function refreshSleepMode() {
      if (state.manualSleep) {
        state.sleepMode = true;
        return;
      }

      if (state.agents.length > 0) {
        state.lastActiveAt = Date.now();
        state.sleepMode = false;
        return;
      }

      state.sleepMode = Date.now() - state.lastActiveAt >= SLEEP_AFTER_MS;
    }

    function agentKey(agent) {
      if (agent.char === "sleep") return "sleep";
      return `${agent.char}`;
    }

    function createAgentNode(agent) {
      const agentEl = document.createElement("div");
      agentEl.className = "agent entering";

      const nameEl = document.createElement("div");
      nameEl.className = "agent-name";

      const imgEl = document.createElement("img");
      imgEl.className = "sprite";
      imgEl.loading = "lazy";
      imgEl.addEventListener("error", () => {
        if (imgEl.dataset.fallback === "1") return;
        imgEl.dataset.fallback = "1";
        imgEl.src = framePath("opus", ((state.frameIndex % FRAME_COUNT) + 1));
      });

      const timerEl = document.createElement("div");
      timerEl.className = "timer";

      agentEl.appendChild(nameEl);
      agentEl.appendChild(imgEl);
      agentEl.appendChild(timerEl);

      agentEl.addEventListener("animationend", () => {
        agentEl.classList.remove("entering");
      }, { once: true });

      return {
        el: agentEl,
        nameEl,
        imgEl,
        timerEl,
        char: agent.char,
        removing: false,
      };
    }

    function updateAgentNode(node, agent, idx) {
      const frameNumber = ((state.frameIndex + idx) % FRAME_COUNT) + 1;

      if (node.char !== agent.char) {
        delete node.imgEl.dataset.fallback;
      }

      node.char = agent.char;
      node.nameEl.textContent = agent.char;
      node.imgEl.alt = agent.char;

      const spriteChar = node.imgEl.dataset.fallback === "1" ? "opus" : agent.char;
      const nextSrc = framePath(spriteChar, frameNumber);
      if (node.imgEl.src !== nextSrc) {
        node.imgEl.src = nextSrc;
      }

      node.imgEl.title = agent.task ? `${agent.char}: ${agent.task}` : `${agent.char}: (taskãªã—)`;

      node.timerEl.style.animationDelay = `${idx * 0.2}s`;
      node.timerEl.textContent = formatElapsed(agent.started);
    }

    function removeAgentNode(key, node) {
      if (!node || node.removing) return;
      node.removing = true;
      node.el.classList.add("leaving");
      window.setTimeout(() => {
        if (node.el.isConnected) {
          node.el.remove();
        }
        state.agentNodes.delete(key);
      }, 430);
    }

    function syncAgentNodes(agents) {
      const desiredKeys = [];

      agents.forEach((agent, idx) => {
        const key = agentKey(agent);
        desiredKeys.push(key);

        let node = state.agentNodes.get(key);
        if (!node) {
          node = createAgentNode(agent);
          state.agentNodes.set(key, node);
        }

        if (node.removing) {
          node.removing = false;
          node.el.classList.remove("leaving");
        }

        updateAgentNode(node, agent, idx);
        lobsterRow.appendChild(node.el);
      });

      for (const [key, node] of state.agentNodes.entries()) {
        if (!desiredKeys.includes(key)) {
          removeAgentNode(key, node);
        }
      }
    }

    function triggerCountPop() {
      countValueEl.classList.remove("pop");
      void countValueEl.offsetWidth;
      countValueEl.classList.add("pop");
    }

    function updateCount(count) {
      countValueEl.textContent = `x${count}`;
      countEl.classList.toggle("danger", count >= 7);

      if (count < 7) {
        countEl.style.color = countColor(count);
      } else {
        countEl.style.color = "#ff4d4d";
      }

      if (state.lastRenderedCount !== count) {
        triggerCountPop();
        state.lastRenderedCount = count;
      }
    }

    function setTickerText(nextText) {
      if (nextText === state.lastTickerText) return;

      if (state.tickerFadeTimer) {
        clearTimeout(state.tickerFadeTimer);
      }

      tickerEl.classList.add("fade-out");
      state.tickerFadeTimer = setTimeout(() => {
        tickerEl.textContent = nextText;
        tickerEl.style.animation = "none";
        void tickerEl.offsetWidth;
        tickerEl.style.animation = "marquee 12s linear infinite";
        tickerEl.classList.remove("fade-out");
        state.lastTickerText = nextText;
      }, 160);
    }

    function formatPollTime(ts) {
      if (!ts) return "--:--:--";
      return new Date(ts).toLocaleTimeString("ja-JP", { hour12: false });
    }

    function updateDebugPanel() {
      const agentsPoll = state.pollStatus.agents;
      const todoPoll = state.pollStatus.todo;

      debugPanelEl.textContent = [
        `agents: ${state.agents.length}/${MAX_AGENTS}`,
        `sleep: ${state.sleepMode ? "ON" : "OFF"} (manual: ${state.manualSleep ? "ON" : "OFF"})`,
        `widget: ${state.widgetHidden ? "hidden" : "visible"}`,
        `/agents: ${agentsPoll.state} @ ${formatPollTime(agentsPoll.lastAt)}`,
        `/todo: ${todoPoll.state} @ ${formatPollTime(todoPoll.lastAt)}`,
        `source: ${state.sourceStatus}`,
        `last error: ${state.lastFetchError || "none"}`,
      ].join("\n");

      debugPanelEl.classList.toggle("show", state.debugVisible);
    }

    function markPoll(kind, status, error = "") {
      state.pollStatus[kind] = {
        state: status,
        lastAt: Date.now(),
        error,
      };
      updateDebugPanel();
    }

    function render() {
      refreshSleepMode();
      const agents = visibleAgents();

      widget.classList.toggle("sleep-mode", state.sleepMode);
      widget.classList.toggle("widget-hidden", state.widgetHidden);

      syncAgentNodes(agents);

      const count = state.sleepMode ? 0 : agents.length;
      updateCount(count);

      setTickerText(currentTickerText());
      updateDebugPanel();
    }

    function tickFrame() {
      state.frameIndex = (state.frameIndex + 1) % FRAME_COUNT;
      render();
    }

    async function pollAgents() {
      markPoll("agents", "polling");
      try {
        const response = await fetch("/agents", { cache: "no-store" });
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        const payload = await response.json();
        state.agents = normalizeAgents(payload);
        state.lastFetchError = "";
        if (state.agents.length > 0) {
          state.lastActiveAt = Date.now();
        }
        updateSourceStatus("source: live /agents");
        markPoll("agents", "ok");
        render();
      } catch (error) {
        state.lastFetchError = error?.message || "fetch failed";
        updateSourceStatus(`source: fallback (${state.lastFetchError})`);
        markPoll("agents", "error", state.lastFetchError);
        render();
      }
    }

    async function pollTodo() {
      markPoll("todo", "polling");
      try {
        const response = await fetch("/todo", { cache: "no-store" });
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        const payload = await response.json();
        if (typeof payload?.todo === "string") {
          state.todoText = payload.todo.trim();
        } else if (typeof payload === "string") {
          state.todoText = payload.trim();
        }
        markPoll("todo", "ok");
        render();
      } catch (error) {
        markPoll("todo", "error", error?.message || "fetch failed");
      }
    }

    async function loadAgentsFromFile(file) {
      if (!file) return;
      try {
        const text = await file.text();
        const payload = JSON.parse(text);
        const parsed = normalizeAgents(payload);
        state.agents = parsed;
        if (parsed.length > 0) {
          state.lastActiveAt = Date.now();
        }
        state.lastFetchError = "";
        updateSourceStatus(`source: local file (${file.name})`);
        render();
      } catch (error) {
        updateSourceStatus(`source: local file error (${error?.message || "invalid json"})`);
      }
    }

    function toggleManualSleep() {
      state.manualSleep = !state.manualSleep;
      if (!state.manualSleep && state.agents.length > 0) {
        state.lastActiveAt = Date.now();
      }
      render();
    }

    function toggleDebug() {
      state.debugVisible = !state.debugVisible;
      updateDebugPanel();
    }

    function toggleWidgetHidden() {
      state.widgetHidden = !state.widgetHidden;
      render();
    }

    loadJsonBtn.addEventListener("click", () => jsonFileInput.click());
    jsonFileInput.addEventListener("change", (event) => {
      const file = event.target.files?.[0];
      loadAgentsFromFile(file);
      event.target.value = "";
    });

    document.addEventListener("dragover", (event) => {
      event.preventDefault();
      document.body.classList.add("drag-over");
    });

    document.addEventListener("dragleave", () => {
      document.body.classList.remove("drag-over");
    });

    document.addEventListener("drop", (event) => {
      event.preventDefault();
      document.body.classList.remove("drag-over");
      const file = event.dataTransfer?.files?.[0];
      loadAgentsFromFile(file);
    });

    document.addEventListener("keydown", (event) => {
      const tagName = event.target?.tagName;
      if (tagName === "INPUT" || tagName === "TEXTAREA") return;

      if (event.key === "s" || event.key === "S") {
        event.preventDefault();
        toggleManualSleep();
        return;
      }

      if (event.key === "d" || event.key === "D") {
        event.preventDefault();
        toggleDebug();
        return;
      }

      if (event.key === "Escape") {
        event.preventDefault();
        toggleWidgetHidden();
      }
    });

    render();
    pollAgents();
    pollTodo();
    setInterval(tickFrame, FRAME_MS);
    setInterval(pollAgents, AGENTS_POLL_MS);
    setInterval(pollTodo, TODO_POLL_MS);
  </script>
</body>
</html>
